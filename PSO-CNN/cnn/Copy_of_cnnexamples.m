clear all; close all; clc;
addpath('C:\Users\Administrator\Desktop\dingjianping\PSO-CNN\data');
addpath('C:\Users\Administrator\Desktop\dingjianping\PSO-CNN\util');
load data512newb48;

train_x = double(reshape(train_x',48,48,596))/255;
test_x = double(reshape(test_x',48,48,501))/255;
train_y = double(train_y');
test_y = double(test_y');

%% ex1 
%will run 1 epoch in about 200 second and get around 11% error. 
%With 100 epochs you'll get around 1.2% error

   % disp([num2str(i) '/' num2str(j)]);

cnn.layers = {
    struct('type', 'i') %input layer
    struct('type', 'c', 'outputmaps', 8, 'kernelsize', 5) %convolution layer
    struct('type', 's', 'scale', 2) %sub sampling layer
    struct('type', 'c', 'outputmaps', 12, 'kernelsize',3) %convolution layer
    struct('type', 's', 'scale', 2) %subsampling layer
    struct('type', 'c', 'outputmaps',16, 'kernelsize',3) %convolution layer
    struct('type', 's', 'scale', 2) %sub sampling layer
};

% clpso的参数初始化
opts.w0=0.9;
opts.w1=0.4;
opts.c=1.49445;
opts.sizepar=30;%sizepar为粒子群的数量
opts.m=3; % refreshing map 设为7，参见clpso论文 E Adjusting the Refreshing gap m
cnn.Pc=zeros(1,opts.sizepar); %更新时使用的pc（i）
cnn.flag=zeros(1,opts.sizepar); %对于每一个粒子的判断flag，存在cnn的结构中能够保存下来

% 学习率
opts.alpha = 1;
% 每次挑出一个batchsize的batch来训练，也就是每用batchsize个样本就调整一次权值，而不是
% 把所有样本都输入了，计算所有样本的误差了才调整一次权值
opts.batchsize = 4; 

%循环迭代次数
opts.numepochs = 300;


cnn.par=cell(1,opts.sizepar+1);
cnn.vel=cell(1,opts.sizepar);
% 这里把cnn的设置给cnnsetup，它会据此构建一个完整的CNN网络，并返回
cnn = cnnsetup(cnn, train_x, train_y,opts);
% cnn = cnnsetup_original(cnn, train_x, train_y);
% 然后开始把训练样本给它，开始训练这个CNN网络
cnn = cnntrain_clpso(cnn, train_x, train_y, opts );

% 然后就用测试样本来测试
[mmy, er, bad] = cnntest(cnn, test_x, test_y,opts);
% [mmy, er, bad] = cnntest_original(cnn, test_x, test_y);
 %cao=[cao er*100];

   % caoi=[caoi;cao,zeros(1,i-5)];

%save i200error0320 caoi;
save PSOCNN_48_46 cnn opts;

%show test error
disp([num2str(er*100) '% error']);
